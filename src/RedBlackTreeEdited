package com.company;

import com.company.Node;
import com.company.NodeQuery;
import enums.NodeColor;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

class RedBlackTree {
    //RedBlackTree tree;
    Node root;
    int size = 0;
    private Node tempParent;
    private Node newNode;

    void add(String value) {
        size++;
        tempParent = newNode = null;
        root = add(root, value);
        addFixup(newNode);
    }

    private Node add(Node current, String value) {
        if (current == null) {
            Node node = new Node(value);

            node.parent = tempParent;
            newNode = node;

            return node;
        }

        if (Integer.parseInt(value) < Integer.parseInt(current.value)) {
            tempParent = current;
            current.left = add(current.left, value);
        } else if (Integer.parseInt(value) > Integer.parseInt(current.value)) {
            tempParent = current;
            current.right = add(current.right, value);
        } else {
            // value already exists
            return current;
        }

        return current;
    }

    private void addFixup(Node node) {
        while (NodeQuery.parentOf(node) != null &&
                NodeQuery.grandParentOf(node) != null &&
                NodeQuery.parentOf(node).color == NodeColor.RED) {

            if (node.parent == NodeQuery.grandParentOf(node).left) {

                Node uncle = NodeQuery.grandParentOf(node).right;
                NodeColor uncleColor = uncle == null ? NodeColor.BLACK : uncle.color;

                if (uncleColor == NodeColor.RED) {
                    NodeQuery.parentOf(node).color = NodeColor.BLACK;
                    uncle.color = NodeColor.BLACK;

                    node = NodeQuery.grandParentOf(node);
                    node.color = NodeColor.RED;
                } else {

                    if (node == NodeQuery.parentOf(node).right) {
                        node = NodeQuery.parentOf(node);
                        rotateLeft(node);
                    }

                    NodeQuery.parentOf(node).color = NodeColor.BLACK;
                    NodeQuery.grandParentOf(node).color = NodeColor.RED;
                    rotateRight(NodeQuery.grandParentOf(node));
                }
            } else if (node.parent == NodeQuery.grandParentOf(node).right) {

                Node uncle = NodeQuery.grandParentOf(node).left;
                NodeColor uncleColor = uncle == null ? NodeColor.BLACK : uncle.color;

                if (uncleColor == NodeColor.RED) {
                    NodeQuery.parentOf(node).color = NodeColor.BLACK;
                    uncle.color = NodeColor.BLACK;

                    node = NodeQuery.grandParentOf(node);
                    node.color = NodeColor.RED;
                } else {

                    if (node == NodeQuery.parentOf(node).left) {
                        node = NodeQuery.parentOf(node);
                        rotateRight(node);
                    }

                    NodeQuery.parentOf(node).color = NodeColor.BLACK;
                    NodeQuery.grandParentOf(node).color = NodeColor.RED;
                    rotateLeft(NodeQuery.grandParentOf(node));
                }
            }
        }

        root.color = NodeColor.BLACK;
    }

    boolean search(String value) {
        return search(value, root);
    }

    private boolean search(String value, Node current) {
        if (current == null) return false;
        if (value.equals(current.value)) return true;

        return Integer.parseInt(value) < Integer.parseInt(current.value)
                ? search(value, current.left)
                : search(value, current.right);
    }

// Edited <<<<
    void Size_Decrement() {
        size--;
    }

// Added <<<<
    Node A_search(String str){
        if (root == null){
            return null;
        }
        return A_search(str, root);
    }

// Added <<<<
    private Node A_search(String str, Node node){
        if (str == node.value){
            return node;
        }

        if (str.compareTo(node.value) < 0){
            if (node.left == null){
                return null;
            }
            return A_search(str, node.left);
        }
        if (str.compareTo(node.value) >= 0){
            if (node.right == null){
                return null;
            }
            return A_search(str, node.right);
        }
        return null;
    }

// Added <<<<
    void RB_Delete(String str) {
        Node node = A_search(str);
        Node tempNodeY, tempNodeX;

        if (node.left == null || node.right == null) {
            tempNodeY = node;

        } else {
            tempNodeY = Tree_Successor(node);
        }

        if (tempNodeY.left != null && tempNodeY != null) {   // Not sure about the 2nd condition in this if statement
            tempNodeX = tempNodeY.left;

        } else {
            tempNodeX = tempNodeY.right;
        }

        tempNodeX.parent = tempNodeY.parent;

        if (tempNodeY.parent == null) {
            root = tempNodeX;

        } else {

            if (tempNodeY == tempNodeY.parent.left) {
                tempNodeY.parent.left = tempNodeX;

            } else {
                tempNodeY.parent.right = tempNodeX;
            }
        }
        // not sure
        if (tempNodeY != node) {
            node.value = tempNodeY.value;
        }

        if (tempNodeY.color == NodeColor.BLACK) {
            RB_Delete_Fixup(tempNodeX);
        }
    }

// Added <<<<
    private void RB_Delete_Fixup(Node node){

        while(node != root && node.color == NodeColor.BLACK){
            if (node == node.parent.left){
                Node tempNode = node.parent.right;

                if (tempNode.color == NodeColor.RED){
                    tempNode.color = NodeColor.BLACK;
                    node.parent.color = NodeColor.RED;
                    rotateLeft(node.parent);
                }

                if (tempNode.left.color == NodeColor.BLACK && tempNode.right.color == NodeColor.BLACK){
                    tempNode.color = NodeColor.RED;
                    node = node.parent;

                }else {
                    if (tempNode.right.color == NodeColor.BLACK){
                        tempNode.left.color = NodeColor.BLACK;
                        tempNode.color = NodeColor.RED;
                        rotateRight(tempNode);
                        tempNode = node.parent.right;
                    }

                    tempNode.color = node.parent.color;
                    node.parent.color = NodeColor.BLACK;
                    tempNode.right.color = NodeColor.BLACK;
                    rotateLeft(node.parent);
                    node = root;
                }

            }else {
                Node tempNode = node.parent.left;

                if (tempNode.color == NodeColor.RED){
                    tempNode.color = NodeColor.BLACK;
                    node.parent.color = NodeColor.RED;
                    rotateRight(node.parent);
                }

                if (tempNode.right.color == NodeColor.BLACK && tempNode.left.color == NodeColor.BLACK){
                    tempNode.color = NodeColor.RED;
                    node = node.parent;
                }else {
                    if (tempNode.left.color == NodeColor.BLACK){
                        tempNode.right.color = NodeColor.BLACK;
                        tempNode.color = NodeColor.RED;
                        rotateLeft(tempNode);
                        tempNode = node.parent.left;
                    }
                    tempNode.color = node.parent.color;
                    node.parent.color = NodeColor.BLACK;
                    tempNode.left.color = NodeColor.BLACK;
                    rotateRight(node.parent);
                    node = root;
                }
            }
        }
        node.color = NodeColor.BLACK;
    }

// Added <<<<
    private Node Tree_Successor(Node node) {
        if (node.left != null && node != null) {
            return Tree_Minimum(node.right);
        }
        Node Successor = node.parent;

        while (Successor != null && Successor != null && node == Successor) {
            node = Successor;
            Successor = node.parent;
        }
        return Successor;
    }
    
// Added <<<<
    private Node Tree_Minimum(Node node) {
        while (node.left != null && node != null) {
            node = node.left;
        }
        return node;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        x.right = y.left;

        if (y.left != null) y.left.parent = x;

        y.parent = x.parent;

        if (x.parent == null) root = y;
        else {
            if (x == x.parent.left) x.parent.left = y;
            else x.parent.right = y;
        }

        y.left = x;
        x.parent = y;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        x.left = y.right;

        if (y.right != null) y.right.parent = x;

        y.parent = x.parent;

        if (x.parent == null) root = y;

        else {
            if (x == x.parent.left) x.parent.left = y;
            else x.parent.right = y;
        }

        y.right = x;
        x.parent = y;
    }

    void printPreorder(Node node) {
        if (node == null) return;

        System.out.println(node.value + ", " + node.color);

        printPreorder(node.left);
        printPreorder(node.right);
    }

    void printInorder(Node node) {
        if (node == null) return;

        printInorder(node.left);
        System.out.println(node.value + ", " + node.color);
        printInorder(node.right);
    }

    void loadVocabs() {
        try {
            Scanner scanner = new Scanner(new File("C:\\DS\\vocabs.txt"));
            while (scanner.hasNextLine()) add(scanner.nextLine().trim());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    int findHeight() {
        return findHeight(root);
    }

    private int findHeight(Node aNode) {
        if (aNode == null) return -1;

        int lefth = findHeight(aNode.left);
        int righth = findHeight(aNode.right);

        if (lefth > righth) {
            return lefth + 1;
        } else {
            return righth + 1;
        }
    }
}
